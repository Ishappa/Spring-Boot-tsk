----https://start.spring.io/
----------JDBC----------------
1.Import Packages
2.Load Driver
3.Register Driver
4.Create Conncetion
5.Create Statement
6.Excecute Statement
7.Close

--> to create a jdbc project create mvn project and add library jdbc connector
 --> steps : file-> pro structure-> library-> java-> your mysql connector jar file.

-> Load and Register Driver is automatically done by the java after java 6 version.

Springs:  Lightweight Framework 

we can refer the website spring.io and spring documentation.

 Apache Tomcat:  is an open-source web server and Servlet container for Java code.
 
 IOC(Inversion of control): controlling the objects and flow
 
 -> its a container and it includes a objects.
 
 ---------------------------Spring IoC (Inversion of Control):------------------------------

--------xml base-------------




--------java-config:--------

-->To create a project we need Dependency 1. Spring context 
--> use @Component for all class 
-->use @Configeration and @ComponentScan for config class.
-->@ComponentScan-> it wll scan all compo class if we have multiple compo class(exampl: laptop and desktop).
-->use @primary for which one we have to take imple or consider or qulifier the class.

--> 3 ways for qualifier for class if we have multiple imple for single interface: 
1. use @Qualifier("lap") top of getmathod of intialize bean and ("lap") -> should metion @Component("lap") on laptop class.
2. we can use lowercase class name directly example: @Qualifier("laptop").
3. we can use @primary of top of our component class ex: Laptop class.

-->if you use all at same time priority more will be @Component("lap") --> @Qualifier("lap")

-> below example it will take imple of method of compouter is laptop.


ex:    @Autowired
    @Qualifier("lap")// i used @primary for Desktop but still calling lap implementation priority more for this
    public void setCom(Computer com) {
        this.com = com;
    }
 

-> Container is the core of Spring Framework. 
-> It creates the objects, configures and assembles their dependencies, manages their entire life cycle.
-> The Container uses Dependency Injection(DI) to manage the components that make up the application.
-> Spring IoC is the mechanism to achieve loose-coupling between Objects dependencies.
-> To achieve loose coupling and dynamic binding of the objects at runtime, objects dependencies are injected by other assembler objects.

 Springs : its a framework and we have do dependency injection.
 -> Requires more manual setup and configuration.
 ->  Ideal for large, complex enterprise applications where you need control over configurations and components.
 
ApplicationContext: its used to get the objects from the container.
-> its not a part of java its a part of spring 
-> we need to add some dependencies while wokring with spring project 
(browse the mvnrepository and search for spring context add the dependencies in pom file of our project).

-> spring xml configuration : we can get the defenitoin from (browse: spring xml confingeration and copy and paste it in resource ml.file) 

Beans/Spring beans: 
-> beans are the objects and these managed by the springs.

.xml

example: defaulty scope="singleton" will be, it means create only one obj when you using same id
		-> but when use scope="prototype" it will cerate diffrent obj when you call by using same id
		
<bean id="alien1" class="org.ish.Alien" scope="prototype">
</bean>


 DI(Dependency Injection): 
 

 Spring boot: its a standalone application----------------------------
 
 -> Provides auto-configuration and defaults to minimize setup time.
 ->  Perfect for microservices, REST APIs, and any application where you want to get up and running quickly with minimal configuration.
 -> IoC Container: The Spring Boot application context acts as the IoC container.
 
 -> Spring Boot uses IoC to manage beans and their dependencies, enabling auto-configuration and providing sensible defaults. 


1.Ecliplse go to help -> -> ecliplse market place -> search for springboot 6 and download the 
2.intellije community version we can create project from start.spring.io


Reference:SpringBootDemo

--> @Component: annotation on Laptop and Alien classes tells Spring that these classes are Spring components.
--> @SpringBootApplication: annotation in the SpringBootDemoApplication class enables component scanning,
 which means Spring will scan the specified package (and its sub-packages) for classes annotated with @Component, @Service, @Repository, @Controller, etc.

--> During the startup, Spring creates instances (beans) of all the classes annotated with @Component and registers them in the application context.
--> @Autowired: annotation on the laptop field in the Alien class tells Spring to inject an instance of Laptop into the Alien class.
		Spring finds the Laptop bean in the application context and injects it into the Alien bean.

------------------------------Spring JDBC-------------------------------
To achive this project

-->using RowMapper we can fetch the data from table.(used in repo)


1.we have to use springjdbc dependency.
2.h2 dependency for storing data without using external database we can create table and store data inside the project only.
-> h2 is a embedded database
ex:in pjct structure under resourcepackage->for create table create schema.sql file and data.sql for adding data.

------------------Spring jdbc working or connecting mysql same project -------------
-> no need to change anything in code.
-> pom.xml add mysql dependency and comment or remove h2 dependency.
->go to resource folder and open application.properties file -> and add below lines.

	spring.datasource.url = jdbc:mysql://localhost:3306/springjdbcdemo
	spring.datasource.username = root
	spring.datasource.password = root
	spring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver

------------------Java Servlet/ web app----------------------------------------------------------

->create a mvm project and add dependencies in pom
1. jakarta servlet -4.0.4
2. tomcat embedded -8.5.96

-->mvc proj structure webapp folder under 2 folders--> views and WEB-INF
--> under views write jsp pages.
--> under web-Inf write create 2 xml files --> web.xml and dispatcher-servlet.xml.

web.xml
--------------
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         id="WebApp_ID" version="3.1">

    <display-name>spring-mvc-demo</display-name>

    <absolute-ordering />

    <!-- Spring MVC Configs -->

    <!-- Step 1: Configure Spring MVC Dispatcher Servlet -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!-- Optional: Specify the location of the Spring configuration file [<init-param>: Optional if your configuration file is named dispatcher-servlet.xml]-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-mvc-demo-servlet.xml</param-value>
        </init-param>

        <!-- Optional: Load the DispatcherServlet at application startup -->
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!-- Step 2: Set up URL mapping for Spring MVC Dispatcher Servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>


dispatcher-servlet.xml(instead of dispactcher you can use different name but it should be same in servlet-mapping for name in web.xml file)
---------------------

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:ctx="http://www.springframework.org/schema/context"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context 
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd">

  <!-- Step 3: Add support for component scanning -->
    <ctx:component-scan base-package="com.ish" />

    <!-- Step 4: Add support for conversion, formatting and validation support -->
    <mvc:annotation-driven/>

    <!-- Step 5: Define Spring MVC view resolver -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
</beans>


---------------MVC------------------
1.Model-->POJO(plain old java objects)-->model contains data in the form of objects.
2.View--> JSP (Java server page)--> it contains html content for respose the data to clients.
3.Controller --> Servlet--> recives the request from clients and sent it to the model.

----step by step process of MVC----

-->clients request will come to Controller--> then its send to model it willl get data from database or any --> then it will send respoce to 
View stage (jsp). 

--> tomcat will able to run only servlets behind the scene jsp page will convert in to servlet


----------------------------------Create a SpringBoot Web project-----------------------

-->Use Spring.io for creating project and use jar file beacause springweb includes default embedd tomcat you are working on tomcat server.

--> while creating add dependency Spring web
--> inside under main folder you have to create webapp folder and under this folder create index.jsp file/ file name can be different.
--> write some code in the file. and jsp file will handle or call by the controller .
--> when client send request to server, controller handles the request first, processes it, and then forwards it to the JSP view to render the response.
--> url will be or path depends on method top of.

--> to convert jsp into servlet we have to one more dependency--------------
1. goto mvnrepo -> search tomcat server -- check our embed tomcat server version in pjct(external lib)(10.1.25) --> download same -> tomcat jasper.
2. then add dependecy in pom file

-->HttpSession : HTTP sessions store user data across multiple requests.
-->HTTP Session Usage: You can set, get, and invalidate session attributes using HttpSession.
--> when we want to diplay our result from from or any respose to webpage use seesion for set attribute the displaying using jsp file

--> instead using HttpSession we can use Model object for get or set the response the data to webpage/ jsp -----------------------------

@HttpSession: Session scope, long-lived, user-specific data, accessible across multiple requests and controllers.
@Model: Request scope, short-lived, transient data, accessible only within the current request handling method and the view rendered by it.

--> in controller class instead of using retun index.jsp or any our jsp file using extension .jsp we can create other folder put all files in it (ex: views folder)
--> under webapp -> views -> move all jsp files from webapp to views -> write properties inside application.poprty file it will be under resource folder. 
	->even refer website(Search as Spring applction property).

--------------------------// instead of using Model we can using ModelAndView object------------------
Model: Simplifies adding multiple attributes to the view, used as a method parameter, best for straightforward cases.
ModelAndView: Encapsulates both the model and the view in a single object, used as a method return type, offers greater flexibility for complex scenarios

--------------------------------------------------SpringMvc-------------------------------

->using ecliplseIDE or create pjct using Spring.io
-> create mvn project and selct catelog -> internal with -> mvn-webApp -> provide g id and arch id.
-> after creating a project somw errors will show
-> index.jsp is no need we can delet it
-> if java folder not available default under src->main->we can crete folder as java then automatically src/main/java it will get create under pjct.

-> create folder structure something called com.ish.SpringMvcDemo under java folder it will reflect under src/main/java we can create package as com.ish.SpringMvcDemo. 
-> then we can create classes under  src/main/java -> com.ish.SpringMvcDemo this package.

--> we need 3 dependecies.for this spring mvc pjct
1. mvnrepository-> search for Spring mvc select-> Spring Web MVC -> version 3rd last relased or 2nd / 6.1.0.
2. click on server in project and download apache last one 10. version specify directry where it should download and after dowloaded select our project.

Configur dispactcher servlet.
-------------------------------
--> open web.xml file under webApp and add servlet class and name  
--> org.springframework.web.servlet.DispatcherServlet.class(you will get this from library-> mvn depen-> webmvc jar-> org.---.servlet-> dispatcherservlt.class (copy qulified name). )
example: 
<servlet>
  <servlet-name>ish</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet.class</servlet-class>
  </servlet>
  
  <servlet-mapping>
  <servlet-name>ish</servlet-name>
  <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app> 

Set up Internal view Resource Resolver
--------------------------------------------
for above web.xml file we have to create refrence for resolver file (ish-servlet.xml). 

    <ctx:component-scan base-package="com.ish" />
    <ctx:annotation-config/>

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>


-----------------------------JobApp Spring boot------------------------------------
1. create maven prjt using spring initializer(spring.io).
2. while creating add dependency are SPring web and lombok.
3. add 3 more dependencies in pom file by searching in mvnrepo website

--> whenever work with jsp pages its needed.

	1.tomcat jasper(10.1.25).
	2. jsp.jstl-api(3.0.0)
	3. jsp.jstl(3.0.0)


PROCESS: client -> Controller -> Service -> Repo -> database/file/or any server

--------------------------Rest using Spring Boot---------------------------

REST (Representational State Transfer):  is a way to design web services that interact over the internet. It's based on standard web protocols, mainly HTTP

1. Resources: Everything in REST is considered a resource, like users, job posts, or products. Each resource is identified by a unique URL.

2. HTTP Methods: REST uses standard HTTP methods to perform operations on resources:

	GET: Retrieve a resource.
	POST: Create a new resource.
	PUT: Update an existing resource.
	DELETE: Remove a resource.
	PATCH: Partially update a resource.



end to end process:

1.User Interaction: User interacts with the web page.
2.Sending a Request: Frontend sends an HTTP request to the backend.
3.Receiving the Request: Backend controller receives the request.
4.Processing the Request: Controller processes the request, calling service methods.
5.Database Interaction: Service methods interact with the repository layer to query or update the database.
6.Generating the Response: Backend generates a response with the requested data.
7.Sending the Response: Backend sends the response back to the frontend.
8.Handling the Response: Frontend processes the response and updates the UI.



-------------------------Rest project process or structure----------------------------------

refer the project and compare JobApp and Spring-boot-rest--
--> Controller class will return the data instead of returning view name and use @RestController top of class .
	example:  @GetMapping("jobPosts")
   		  public List<JobPost> getAllJobs(){
	          return service.getAllJobs();
		 }


-----------------------------Understanding the React UI------------------------

1. After creating react proj run : npm install -g json-server
2. run cmd : json-server --watch db.json --port 8000  
	--> we are setting run our server on port 8000 default will be 3000.   
	ex: JSON Server started on PORT :8000
	Watching db.json...
	Static files:
	Serving ./public directory if it exists

	Endpoints:
	http://localhost:8000/posts

3. open new terminal run 
	cmd: npm install --> for  install packages 

4. after installed run application
	cmd: npm start


----------------------------211. Connecting React and Spring-------------------------
--> set out backend fetch url path to react file src->compo->.jsx file ->  

	example: const response = await axios.get(`http://localhost:8080/jobPosts`); //this path from the backend
--> run react projct --> cmd: npm start
	

--> take default url of react after run the react project set cross origin in backend rest controller class

example:
	@RestController
	@CrossOrigin(origins = "http://localhost:3000/") 
	or you can use backend url as proxy in react package.json file(ex:  "proxy": "http://localhost:8080"}) 
	and no need use full path for crud ex:get('/jobPosts'); proxy will concatinate internally.
	
	public class JobRestController {

--> getting job based on ID and pathvariable need to specify out variable name if we have multiple.

    @GetMapping("jobPost/{jobId}")
    public JobPost getJob(@PathVariable("jobId") int jobId){
        return service.getJob(jobId);
    }


-->when you want add/post or put/update data to server we need @RequestBody this is important achive add data inside server.

ex:     @PostMapping("jobPost")
    public JobPost addJob(@RequestBody JobPost jobPost){
         service.addJob(jobPost);
//        return jobPost; //what we are that will return
       	  return service.getJob(jobPost.getPostId());// adding obj and fetching obj from server or source.
    }

--> in library list deafult in our project exist jackson library its use for convert object to json format.
--> if we want to work or convert into xml format we need to add dependecy called jackson dataformat xml in pom file.
	(version should be same as jackson which already present in library).ex: 2.17.2

--> when you search path in postman/any we have set header as
	key: Accept
	value: application/xml then run it returns data in xml format.


--> instead of set header directly we can use to methods for recieve and respose data type

example :  @GetMapping(value = "jobPosts" , produces = "application/xml")--> for fetching or recive to the end user
	    @PostMapping(value = "jobPost", consumes = "application/json")--> server takes only json type data.	



-----------------------------------------------Spring Data Jpa---------------------------------------------------------------

--> Hibernate: its a tool is used to store a data into database it will create table by using annotations.
	--> it will make a code less.

-->JPA : Repository layer
	its says no need to write a lot of code and its simplyfies it will give some methods we can use it.

--> To create a project use spring.io and we need dependecy as 1. Spring data jpa 2. Mysql connecter  .

--> we have set the application properties for connect to db and create a table.

Syntax:  

spring.datasource.url = jdbc:mysql://localhost:3306/springjpa
spring.datasource.username = root
spring.datasource.password = root
spring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver

spring.jpa.hibernate.ddl-auto = update     --> update is use create a table if not prsent and if created alreday update values .
spring.jpa.show-sql=true

--> create a class make it as @Entity and @compo
--> create interface extends JpaReposi<classname, Integre>  @repository. integer mean-> primaryKey.
--> create obj for class and inetrface in spring class.


--> to save the data of obj into database call this method parameter obj reference->repo.save(s1); 

-----> System.out.println(repo.findAll());// to fetch and display all rows from table.
----> System.out.println(repo.findById(101));// display based on Id.

---------------Update and Delete-----------

Update--> modify our objcts values which one want to update and  call repo.save(s2).
Delete--> call delete method repo.delete(s2).



-----Query DSL-------------

---> In Repo insterface you can Write custome method which is not available predefined method under repo.
--> custome method name should be proper and related to querry for such as findByName() ,findByMarksGreaterThan(), findByMarksLesserThan etc..
--> later you can use them in main class (Springbootapli)to call.

example: @Repository
public interface StudentRepo extends JpaRepository<Student,Integer> {

List<Student> findByName(String name);

List<Student> findByMarks(int marks);

List<Student> findByMarksGreaterThan(int marks);
}

-------------Connect Spring-boot-Rest project(JobApp) to store data into db----------------------
JPA:

-->dependency needed--> 1. data-jpa and 2. mysql-connector.
-->application properies for conncet db and jpa.
-->if we have collection of data in one column we can use @ElementCollection on top of variable --> it will create new table with forign key.
	example:   @ElementCollection
  		  private List<String> postTechStack;
--> instead of writing custome code for repository class, create interface as repo and extends JpaRep<classname, Integer>{}.
--> we can use all obj inside service class only create one method for load all obj or save all.

------------Search By keyword----------------


--> create custome method in repo call it in service and controller .

example : List<JobPost> findByPostProfileContainingOrPostDescContaining(String postProfile, String Desc);

	explanation: its chceking keyword exist(ex: java or any) in posts profile or posts desc then filter jobs and display.

explain: findByPostProfile and findByPostProfile --> it will read internally find based on PostProfile and PostDesc variable and Containing is reserve keyword for checking keyword.

--> it helps reduce a code for storeing and fetching data to db by using inbuild methods.


example: Repository layer

--> its says no need to write a lot of code and its simplyfies it will give some methods we can use it.

-->Service : jus for connect our request and call for repository.

--------------------------Spring Data Rest-----------------------------------------------------

use for: it will simplifies building RestFul Apis by exposing repo interfaces directly as Restfull endpoints. 

--> here we will remove service and controller layer no need to create controller and service explicitly.
--> we will use only repository layer.
--> we can perform crud operations.
-->Spring Data REST generates RESTful endpoints for entities managed by JPA based on repository interfaces.

Project :

--> 1st we should existing table which already created by jpa or spring rest jpa.
--> we need 2 dependecy: 1. spring data jpa 2. rest repository.
-->create model class (Entity class structure class name should be which one we used for spring boot res jpa project). 
--> create repo interface extend jpa(repo name also should be same). or jus create repo and extends jpa .
-->add appli prop for mysql and jpa database name should be which already created table by using and maneged by jpa or spring boot rest.




--------------------Spring AOP-----------------------------
refer official website: spring aop concepts.

--> Aspect oriented program..
--> use for write business logic handle exceptions , log errors and more..
-->while excecuting a program or methods logs are use for security, validation and exception handling..

Advices: before, after, when, where should exceute logs.(we will use majorly for methods.)


-------------------To create a aop class-----------------

--> use top of class @Component and @Aspect
--> create logger obj.
--> then create method

example: 

1.	// @Before("execution(return type, class-name.method-name(args))")

	// *-> means all and i am writing for service class all method when each executes.

    @Before("execution(* com.ish.spring_boot_rest_jpa.service.JobService.*(..))")
    public void logMethodCall(){
        LOGGER.info("Method Called");
    }


2.    @Before("execution(* com.ish.spring_boot_rest_jpa.service.JobService.updateJob(..))")//--> based on method when should execute(joint process)

	@Before("execution(* com.ish.spring_boot_rest_jpa.service.JobService.getJob(..)) || execution(* com.ish.spring_boot_rest_jpa.service.JobService.updateJob(..))")
    	public void logMethodCall(JoinPoint jp){
        LOGGER.info("Method Called "+ jp.getSignature().getName());
    }


-------------------------------------------------SPRING SECURITY----------------------------------------------

1. Application should work properly.
2. good performance of application.
3. stable

https://owasp.org/www-project-top-ten/
OWASP top10 --> standard awareness document for developers and web application security. 


Create a Project:
--------------------------------
--> spring.io and add dependencies are
	1. Spring web 
	2. Spring Security
	--> when you add Spring security dependecies internally one more layer will add filters (default securityfilter chain).
		exampl: authentication filter for login and logout, etc....
	
	process:
	when clinet sends a request it will go in ordering or securityfilter then servlet will give response.
	
	exampl: client request --> servlet container--> filter 1 --> filter 2--> filter N--> Servlet.then revese the response.
	
	3. Spring boot dev tool
	
	
--> when you want restrict to acces your page or site.

-->if you want to update uses name and password for login 
--> you have to write properties in application.properties file.
	example:
			spring.security.user.name=ish
			spring.security.user.password=1234

-----------CSRF-----------------------
-->if 3rd party try to access session id they should have csrf token else they cant enter accss only by seesion id, spring will provide to our site for security purpose.
-->working with REST crud methods we can work with only get method because its safe method.
--> when you working with update or post we should need CSRF token for authention or authorize accessible.
--> set header in X-CSRF-TOKEN as your csrf token write a get method for csrf token then paste it in header.

exampl:   @GetMapping("csrf-token")
    public CsrfToken getcsrf(HttpServletRequest request){
        return (CsrfToken) request.getAttribute("_csrf");
    }

few chnages also needed to make site more secure
===================================== ==============================

1. server.servlet.session.cookies.same-site=strict                                (no one can redirct to our site by 3rd party)

-->	This configuration increases security by ensuring that session cookies are only sent with requests from your site, 
	blocking them from cross-site requests. This helps prevent certain CSRF attacks.
	
2. generates new sessionId for each request by using Secuity configuration.

	*StateFull: After login every requsrt from user even refresed for each time same session ID will be in cookies . 
	*StateLess: After login every requsrt from user even refresed for each time, new session ID will be generate in cookies . 

-------------Making site as a stateless mean no need session csrf token for post and put and write our own sec config-----------------------

-->create spring security config class to create our own security configuration instead of default spring security configuration.

- disabling csrf token generates--
-->making site as stateless. means it should generates new session id for each request and refreshed the page and no need to pass csrf token.

-->Important : 
--> make generates new sessionId each request(it will make a secure applction) or evry time. they can't acces our server.

Create a multiple users
========================================
  // for provide own user details
   
example:@Bean
    public UserDetailsService userDetailsService(){
	    UserDetails user = User
                            .withDefaultPasswordEncoder()
                            .username("ish")
                            .password("1234")
                            .roles("USER")
                            .build();

        UserDetails admin = User
                            .withDefaultPasswordEncoder()
                            .username("admin")
                            .password("admin")
                            .roles("ADMIN")
                            .build();

        return new  InMemoryUserDetailsManager(user,admin);
    }

-->we should connect db using application.properties  
-->we need to create a bean for AuthenticationProvideer for authenticate the user details.
--> then it store in object using DaoAuthenticationProvider. 

-------------------STEPS TO CONNECT OR GET USER DETAILS FROM DB TO VALIDATE FOR LOGIN for multiple users login------------------
1. inside Congfig class:
-->	use @configeration and @EnableWebSecurity

-->	@Autowired
    private  UserDetailsService userDetailsService;


-->    @Bean
    public AuthenticationProvider authenticationProvider()

    {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();

        provider.setUserDetailsService(userDetailsService);
       // provider.setPasswordEncoder(NoOpPasswordEncoder.getInstance());
	    provider.setPasswordEncoder(new BCryptPasswordEncoder(12));		//--> convert your entering password to as a encoded then matching with db

        return provider;
    }

2. create User model class and declare varible whatever used in table in db.
-->
@Data
@Entity
@Table(name = "users")
public class User {
    @Id
    private int id;
    private String username;
    private String password;

}

3. create dao package and create repo interface

--> getting the user detail by username.

@Repository
public interface UserRepo extends JpaRepository<User, Integer> {
    User findByUsername(String username);
}

4. create modelclass as a UserPrinciple or any name like UserDetailsByname 

-->UserDetails is a inbuilt interface implement all methods.and get username and getpassword from user.
--> create User varible and impoert our use model class package pass user as constructor to the below class.

public class UserPrincipal implements UserDetails {

    private User user;

    public UserPrincipal(User user){
        this.user=user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singleton(new SimpleGrantedAuthority("USER"));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

5. create service class MyUserDetailsService and implemet inbuilt UserDetailsService and override methods. (org.springframework.security.core.userdetails.)
--> here using repo obj calling the method inside overriden method and return the new UserPrincipal(user);

@Service
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepo repo;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
      User user = repo.findByUsername(username);
        if(user==null){
            System.out.println("User 404");
            throw new UsernameNotFoundException("User 404");
        }
        return new UserPrincipal(user);
    }
}

6. create a user with encoded password.

--> to achive this while storing the password we have to enocode it. 
--> we have to create controller for register user

@RestController
public class RegisterUserController {

    @Autowired
    private RegisterUserService service;
    @PostMapping("register")
    public User register(@RequestBody User user){
     return service.addUser(user);
    }
}

--> we have to create a service for register and save the user using jpa here we have to encode the password .

@Service
public class RegisterUserService {

    @Autowired
    private UserRepo repo;

    private BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);

    public User addUser(User user){
       user.setPassword(encoder.encode(user.getPassword()));
        System.out.println(user.getPassword());
        return repo.save(user);
    }
}


Key Points to Remember:
---------------------------------------
1. Configuration Class:

Annotate your configuration class with @Configuration and @EnableWebSecurity.
Autowire the UserDetailsService to load user-specific data.
Define an AuthenticationProvider bean using DaoAuthenticationProvider for database authentication. 
Ensure the correct UserDetailsService and PasswordEncoder are set.

2. User Entity:

Ensure your User entity class is properly annotated with @Entity and @Table to map to the correct database table.
Include all necessary fields (id, username, password) with appropriate annotations like @Id for the primary key.

3. User Repository:

The UserRepo interface should extend JpaRepository to leverage Spring Data JPA.
The custom method findByUsername(String username) allows finding a user by their username.

4. Custom UserDetails Implementation:

Implement the UserDetails interface in a class (e.g., UserPrincipal).
Provide implementations for getAuthorities(), getPassword(), and getUsername() based on your User entity.
Use Collections.singleton(new SimpleGrantedAuthority("USER")) to assign a default role. This can be customized as needed.

5. Custom UserDetailsService Implementation:

Implement UserDetailsService in a service class (e.g., MyUserDetailsService).
Autowire the UserRepo to access the database.
Override loadUserByUsername(String username) to fetch the user and wrap it in your UserPrincipal class.


-----------------------------------------USERSTANDING WORKFLOW FOR THE ABOVE LOGIN TASK---------------------------------
1. User Attempts to Log In
Class/Component Involved: Login form or HTTP request
Action: A user submits a login request (typically via a form or an HTTP request) with a username and password.

2. Spring Security Filter Chain
Class/Component Involved: SecurityFilterChain
Action: The request passes through Spring Security's filter chain. The filter responsible for authentication is UsernamePasswordAuthenticationFilter.

3. Authentication Manager
Class/Component Involved: AuthenticationManager
Action: The UsernamePasswordAuthenticationFilter delegates the authentication request to the AuthenticationManager. 
		This manager is responsible for processing the authentication request.

4. Authentication Provider
Class/Component Involved: DaoAuthenticationProvider

Action: The AuthenticationManager delegates the request to an AuthenticationProvider, specifically the DaoAuthenticationProvider (configured in your @Bean method).

Method Called: authenticate(Authentication authentication)

This method calls the UserDetailsService to load user-specific data.

5. Loading User Details
Class/Component Involved: MyUserDetailsService (your custom implementation of UserDetailsService)
Method Called: loadUserByUsername(String username)
Action: This method retrieves the User entity from the database using the UserRepo.

6. User Details Loaded
Class/Component Involved: UserPrincipal (your custom implementation of UserDetails)

Action: The User entity is wrapped into a UserPrincipal object.

Method Implemented:

getPassword(): Returns the password of the user.
getUsername(): Returns the username of the user.
getAuthorities(): Returns the authorities (roles) of the user.

7. Password Verification
Class/Component Involved: DaoAuthenticationProvider
Method Called: additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)
Action: Compares the password provided by the user with the password retrieved from the UserPrincipal (which was fetched from the database). 
		The comparison uses the configured PasswordEncoder (e.g., NoOpPasswordEncoder).

8. Successful Authentication
Class/Component Involved: AuthenticationManager & SecurityContextHolder

Action: If the password matches, the DaoAuthenticationProvider returns an Authentication object, which is then stored in the SecurityContextHolder.

Security Context: Stores the authenticated user's details and allows access to them across the application.

9. User Redirected
Action: Upon successful authentication, the user is redirected to the originally requested URL or a default page.



























































---------------------important Annotations and uses in spring boot-------------------------------------------


1. @SpringBootApplication
-->Purpose:
	It's a composite annotation that includes @Configuration, @EnableAutoConfiguration, and @ComponentScan.
	This annotation marks the main class of a Spring Boot application.
	
-->Workflow:
	When the application starts, Spring Boot scans the package and sub-packages for components, configurations, and services.
	It automatically configures the application based on the dependencies found.
	
2. @Configuration
-->	Purpose:
	Indicates that the class can be used by the Spring IoC container as a source of bean definitions.

-->	Workflow:
	Classes annotated with @Configuration can define beans using @Bean methods. These beans are managed by the Spring container.
	
3. @EnableAutoConfiguration
-->	Purpose:
	Enables Spring Boot's auto-configuration mechanism.

-->	Workflow:
	Automatically configures the application based on the dependencies available in the classpath, minimizing the need for manual configuration.

4. @ComponentScan
-->	Purpose:
	Tells Spring to scan the current package and its sub-packages for annotated components.

-->	Workflow:
	Automatically detects classes annotated with @Component, @Controller, @Service, and @Repository, and registers them as beans.
	
5. @Controller
-->	Purpose:
	Marks a class as a Spring MVC controller, which handles HTTP requests.

--> Workflow:
	Methods annotated with @RequestMapping handle specific HTTP routes.
	The controller interacts with the service layer to process the request and return a view or response.

6. @RestController
--> Purpose:
	Combines @Controller and @ResponseBody, meaning that the controller returns data directly rather than rendering a view.
	
--> Workflow:
	Typically used for RESTful web services. Methods return JSON or XML responses directly to the client.
	
7. @Service
-->	Purpose:
	Indicates that a class is a service, which contains business logic.
	
--> Workflow:
	The service layer interacts with the data access layer (repositories) and is injected into controllers or other services using @Autowired.
	
8. @Repository
--> Purpose:
	Indicates that a class is a repository, which handles data access logic.
	
--> Workflow:
	Spring automatically creates a bean for the repository and manages the data access logic, usually interacting with the database through JPA, JDBC, etc.
	
9. @Component
--> Purpose:
	A generic stereotype annotation indicating that the class is a Spring-managed component.
	
-->Workflow:
	It is a base annotation for @Controller, @Service, and @Repository. These components are automatically registered as beans in the Spring context.

10. @Autowired
--> Purpose:
	Used to inject dependencies into a component automatically.
	
--> Workflow:
	Spring resolves and injects the required bean into the component, ensuring that dependencies are available where needed.
	
	Importatnt:
	
	Example Workflow:
	The application starts with the @SpringBootApplication annotated class.
	Spring Boot scans for components (@Controller, @Service, @Repository).
	Requests come in via a @Controller or @RestController.
	The controller interacts with a @Service to process business logic.
	The service interacts with a @Repository to access data.
	The results are returned to the controller and then to the client.
	
-------------------------------------------------------------	Flow chat:--------------------------------------------
	
													@SpringBootApplication
												   ↓
												@Configuration (for Beans)
												   ↓
												@EnableAutoConfiguration
												   ↓
												@ComponentScan (Scans and registers components)
												   ↓
												@Controller / @RestController ---------------> @Service ---------------> @Repository 
																					↑
																					↓
																			  @Autowired (Dependency Injection)


finally prepare for below points annotation specificall covers all moajor annotation
----------------------------------------------------------------------------------------------
1. Spring Data JPA Annotations

2. Configuration and Dependency Injection

3. Component Scanning and Bean Management

4. Spring Security Annotations

5. Core Annotations

6. Web and REST Annotations

7. Testing Annotations



reference-link code exampl:  https://chatgpt.com/share/53548155-99ee-4fc1-a841-5a01ddc7f65e

----------------------Spring Framework Annotations-------------------------

		1. Spring Data JPA Annotations

		@Entity: Marks a class as an entity.
		@Table: Specifies the table for the entity.
		@Id: Defines the primary key.
		@GeneratedValue: Strategy for primary key generation.
		@Column: Defines a column in the table.
		@Repository: Indicates a DAO class.

		2. Configuration and Dependency Injection

		@Configuration: Declares a class as a source of bean definitions.
		@Bean: Defines a bean.
		@Autowired: Injects dependencies.
		@Qualifier: Specifies which bean to inject.
		@Primary: Gives preference to a bean.

		3. Component Scanning and Bean Management

		@Component: Marks a class as a Spring-managed component.
		@Service: Service-layer beans.
		@Repository: DAO beans.
		@Controller: Spring MVC controllers.
		@RestController: RESTful web services.
		@Scope: Defines bean scope.

		4. Spring Security Annotations

		@EnableWebSecurity: Enables Spring Security.
		@Secured: Specifies roles for method access.
		@PreAuthorize: Specifies method access using expressions.
		@RolesAllowed: Specifies allowed roles (JSR-250).

		5. Core Annotations

		@Value: Injects values from properties.
		@PostConstruct: Method executed after bean initialization.
		@PreDestroy: Method executed before bean destruction.

		6. Web and REST Annotations

		@RequestMapping: Maps HTTP requests to methods.
		@GetMapping: Shorthand for GET method.
		@PostMapping: Shorthand for POST method.
		@PutMapping: Shorthand for PUT method.
		@DeleteMapping: Shorthand for DELETE method.
		@PathVariable: Binds path variables.
		@RequestParam: Binds request parameters.

		7. Testing Annotations

		@SpringBootTest: For Spring Boot application context in tests.
		@DataJpaTest: For JPA testing.
		@WebMvcTest: For Spring MVC controllers.
		@MockBean: Replaces beans with mocks in tests.
		
		
		
---------------------------------------------------Exception Hirarchy----------------------------------
		Throwable
   |
   |-- Error
   |    |-- OutOfMemoryError                // JVM runs out of memory
   |    |-- StackOverflowError              // Excessive deep recursion causes stack overflow
   |    |-- ...                              // Other serious system errors
   |
   |-- Exception
        |
        |-- IOException (Checked)           // General I/O failure
        |    |-- FileNotFoundException      // File not found during an I/O operation
        |    |-- ...                         // Other I/O-related exceptions
        |
        |-- SQLException (Checked)          // Issues related to database access
        |-- ClassNotFoundException (Checked)// Class not found when loading a class by name
        |-- RuntimeException (Unchecked)    // General runtime exceptions (programming errors)
             |-- NullPointerException       // Attempt to use an object reference that is null
             |-- ArrayIndexOutOfBoundsException // Array index out of range
             |-- IllegalArgumentException   // Invalid arguments passed to a method
             |-- ArithmeticException        // Arithmetic operation error (e.g., division by zero)
             |-- ...                         // Other runtime exceptions




1. throw Keyword
----------------------------------
Definition:

--> The throw keyword is used to explicitly throw an exception in Java. It can be used to throw either checked or unchecked exceptions.
--> Used inside a method to actually throw an exception.

example:			public class Example {
--------			public static void checkAge(int age) {
						if (age < 18) {
							throw new IllegalArgumentException("Age must be 18 or older.");
						}
					}

					public static void main(String[] args) {
						checkAge(16); // This will throw an IllegalArgumentException
					}
				}

2. throws Keyword
Definition:

--> The throws keyword is used in a method's signature to declare that the method might throw one or more exceptions. 
	It passes the responsibility of handling those exceptions to the method's caller.
	
example: 
			import java.io.IOException;

			public class Example {
				public static void readFile() throws IOException {
					// Code that might throw an IOException
					throw new IOException("File not found");
				}

				public static void main(String[] args) {
					try {
						readFile(); // This might throw an IOException
					} catch (IOException e) {
						System.out.println("Caught IOException: " + e.getMessage());
					}
				}
			}
			
			
-----------------------Serialization and DeSerialization------------------------------
1. Serialization: is a process

	--> Convert an object into a byte stream(bytecode) machine readeable.
	-->Write this byte stream to a file, send over a network, or store it in a database.
	
example:  --> Serializable is a marker insterface makes class as a serializable class

			import java.io.Serializable;

			public class User implements Serializable {
				private static final long serialVersionUID = 1L;  // This helps in versioning during serialization

				private String username;
				private String email;

				public User(String username, String email) {
					this.username = username;
					this.email = email;
				}

				// Getters and setters (optional)
			}
			
			//------------------main class
			
			import java.io.FileOutputStream;
			import java.io.IOException;
			import java.io.ObjectOutputStream;

			public class SerializeExample {
				public static void main(String[] args) {
					User user = new User("Ishwar", "ishwar@example.com");

					try (FileOutputStream fileOut = new FileOutputStream("user.ser");
						 ObjectOutputStream out = new ObjectOutputStream(fileOut)) {
						out.writeObject(user); // Serialize the object
					} catch (IOException e) {
						e.printStackTrace();
					}

					System.out.println("User object serialized to user.ser");
				}
			}

 

2. Deserialization:

	-->Read the byte stream from a file, network, or database.
	-->Convert the byte stream back into an object.

example: Normal class can consider above one

		//----------main class ---

		import java.io.FileInputStream;
		import java.io.IOException;
		import java.io.ObjectInputStream;

		public class DeserializeExample {
			public static void main(String[] args) {
				try (FileInputStream fileIn = new FileInputStream("user.ser");
					 ObjectInputStream in = new ObjectInputStream(fileIn)) {
					User user = (User) in.readObject(); // Deserialize the object from the file
					System.out.println("User: " + user.getUsername() + ", Email: " + user.getEmail());
				} catch (IOException | ClassNotFoundException e) {
					e.printStackTrace();
				}
			}
		}
		
		
Use Cases:
--------------------
1. File Storage: Persisting the state of an object in a file for future use (e.g., saving user preferences).

2. Network Communication: Sending objects over the network between different systems (e.g., RPC or web services).

3. Caching: Storing objects in a cache for quick retrieval (e.g., session data).
